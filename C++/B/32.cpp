/*
高橋君の会社には、秘密の金庫があります。この金庫にはパスワードをかけているのですが、高橋君はそのパスワードを忘れてしまいました。 しかし、幸運なことに、手元にはパスワードのヒントが以下のように書かれていました。
パスワードは、この紙に書かれている文字列 s の長さ k の部分文字列(※)のどれかである。
高橋君は、ありうるパスワードを全部試せば金庫を開けられる！と喜びました。 しかし、文字列 s はとても長い可能性があるし、しかも同じ部分文字列が複数個文字列 s 中に存在する可能性もあります。明らかに、重複したパスワードを繰り返し試す必要はありません。 そこで、手動で全てのパスワードを試す前に、試す必要がある異なるパスワードの数がいくつあるかを数えることにしました。
あなたの仕事は、文字列 s の内容が与えられるので、試す必要がある異なるパスワードの数がいくつあるかを高橋君に教えてあげることです。
(※)文字列 s の「部分文字列」とは、文字列 s に含まれるある区間を取り出した文字列のことです。 例えば、abc の部分文字列として a,b,c,ab,bc,abc などが挙げられます。 ac や ba などは部分文字列ではないことに注意してください。
*/
#include <bits/stdc++.h>
using namespace std;
int main()
{
    string s;
    int k;
    cin >> s >> k;
    if (s.size() < k)
        cout << "0\n";
    else
    {
        vector<string> arr; // 空の配列を生成
        for (int i = 0; i < s.size() - k + 1; i++)
        {
            arr.push_back(s.substr(i, k)); // arr.push_back()で末尾に要素を追加、str.substr(x,y)でxからy分の字数を取得
        }
        sort(arr.begin(), arr.end());
        arr.erase(unique(arr.begin(), arr.end()), arr.end()); // uniqueで重複しているものを後ろに持っていける(戻り値は不要な要素の初めの要素) -> そこからend()まで不要だからeraseで削除
        cout << arr.size() << endl;
    }
}