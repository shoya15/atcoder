/*
あなたは買い物をしていて，商品リストからいくつかの商品を選んだ．そして今，その商品の価格を合計しようとしている．

ところで，とある集合の任意の部分集合を 2 進数を用いて表す方法が存在し，forループで全ての部分集合(組み合わせ)を列挙する際などに用いることができる．

n 個の商品があり， 商品0,商品1,..,商品n−1 があるとする．添字が0から始まることに注意せよ．
部分集合を表す 10 進整数を X とし，その 2 進 n 桁表現をb_n−1b_n−2...b_1b_0とする．b_0が最下位ビットで b_n−1が最上位ビットである．先頭の0 を許す表現であることに注意せよ．
そして，この整数 X の 2 進表現を用いて，ある部分集合を以下のように定義する．

b_0=1 ならば集合は商品0 を含み，b_0=0 ならば集合は商品 0 を含まない．
b_1=1 ならば集合は商品1 を含み，b_1=0 ならば集合は商品 1 を含まない．
...
b_n−1=1 ならば集合は商品 n−1 を含み，b_n−1=0 ならば集合は商品 n−1 を含まない．
例えば，n=4,X=5 のとき， b=0101 であり，部分集合は {商品0,商品2} である． 簡単にいえば，Xの 2 進表現において，k(0≦k≦n−1) 番目のビットが立っていれば k 番目のアイテムを含むということである．あるビットが立っているかどうかは，多くのプログラミング言語で容易に判定できるので，各自調べられたい．
あなたの仕事は，商品の数，それぞれの商品の価格，そして部分集合を表す 10 進整数 X が与えられるので，部分集合に含まれる商品の価格を合計することである．

※今回の問題には直接関係は無いが，部分集合を上記のように表現することで，大きさ n の集合の全ての部分集合(空集合を含む)を0 ～ 2^n − 1 の連続した整数で表現できるので，全列挙を行う際には応用するとよい．
*/
#include <bits/stdc++.h>
using namespace std;
int main()
{
    {
        int n, x, m = 0;
        cin >> n >> x;
        vector<int> a(n);
        bitset<20> s(x); // n<=20(max) -> bitsetで整数をビット列に変換して、20ビットのビット列として扱う
        for (int i = 0; i < n; i++)
        {
            cin >> a[i];
            if (s.test(i)) // ビットが1になっているかどうかを調べる
                m += a[i];
        }
        cout << m << endl;
    }
}
// int n, x, m = 0;
// cin >> n >> x;
// string b;
// for (int i = 0; i < n; i++)
// {
//     b += to_string(x % 2); // b[i]だとできないから最後に逆順にする
//     x /= 2;
//     if (x == 1)
//     {
//         b += '1';
//         break;
//     }
// }
// reverse(b.begin(), b.end()); // #include<algorithm>

// while (b.size() < n)
// {
//     b = "0" + b;
// }
// reverse(b.begin(), b.end());

// vector<int> a(n);
// for (int j = 0; j < n; j++)
// {
//     cin >> a[j];
//     if (b[j] == '1')
//         m += a[j];
// }
// cout << m << endl;